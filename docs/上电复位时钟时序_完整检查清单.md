# 芯片/bootrom 就绪与 IPC：上电、复位、时钟、时序 完整检查清单

本文档按**电源 → 复位 → 时钟 → 时序**逐项对照代码与 LicheeRV，便于排查「BLOCK_CNT 恒为 0、芯片不回 CFM」时逐项确认每步是否正确。

---

## bootrom 没启动时：电源 / 复位 / 时钟 快速检查

1. **看日志确认**（代码已打下列读回日志，便于检查）  
   - **电源/复位**：上电后应出现 `WiFi GPIO 验证: GPIO0_26=... => OK`；若为 `FAIL`，说明 GPIOA_26 未正确拉高，检查 pinmux(0x0300104C=0x3) 与极性。  
   - **SoC 侧 SD1 复位**：`sd1_host_init` 中 `RSTGEN ... SOFT_RSTN_0=0x...`，**bit17 应为 1**（SD1 释放）；若为 0 则 SD1 仍在复位。  
   - **SoC 侧 SD1 时钟**：`CLKGEN ... clk_en_0=0x...`，**bit21/22/23 应为 1**；`SD1 clock: CLK_CTL=... FREQ_SEL(15:8)=0x80` 表示识别阶段约 400kHz。若出现 `INT_CLK_STABLE did not assert`，可能是时钟源或频率问题。  
2. **时序**：上电拉高到首次 SDIO 访问 = 50ms + `POST_POWER_STABLE_MS`（当前 500ms）。若仍无 CFM，可改为 1000 再测（见 §5.1）。  
3. **硬件**：同一板在 LicheeRV 下能读 chip_rev 则芯片正常，差异多为上电到首包间隔或主机侧时序；可用示波器/逻辑分析仪确认 SDIO CLK 与 CMD53 写 0x107 是否到卡端。

---

## 1. 总体顺序（与 LicheeRV 一致）

| 顺序 | 步骤 | LicheeRV | StarryOS 实现 | 代码位置 |
|------|------|----------|----------------|----------|
| 1 | 电源/复位引脚 pinmux | U-Boot 设 GPIOA_26 为 GPIO(0x3) | **必须先设 pinmux 再驱动 GPIO** | 见下 §2 |
| 2 | 平台上电（GPIO 序列） | power(0)→50ms→power(1)→50ms | 低 50ms→高 50ms | gpio.rs `power_on()` |
| 3 | 上电后稳定延时 | Amlogic 200ms；Allwinner 50ms 高后 rescan | 50ms spin + **500ms** sleep | flow.rs `POST_POWER_STABLE_MS=500` |
| 4 | SDIO 主机复位/时钟 | 由内核/MMC 框架完成 | RSTGEN 释放 SD1 + CLKGEN 使能 SD1 | backend.rs `sd1_host_init()` |
| 5 | SDIO pinmux（数据/CMD/CLK） | 同 U-Boot | D0–D3/CMD/CLK=0，WIFI_PWR=GPIO | backend.rs `sd1_host_init()` |
| 6 | 卡枚举、F1/F2 使能、F1 0x0B/0x11 | probe 内 func_init | 同 | flow.rs `aicbsp_sdio_init()` |
| 7 | 首包 IPC 前 | busrx 已起，无显式 msleep | sleep(100ms) 后 wait_done | flow.rs `send_dbg_mem_read_busrx()` |

---

## 2. 电源（GPIO 上电）

### 2.1 Pinmux：必须先设为 GPIO，再驱动引脚

- **问题**：若在驱动 GPIOA_26 之前**未**将 0x0300104C 设为 GPIO 模式(0x3)，该引脚可能仍为默认功能，**上电序列不会作用到 WiFi 芯片**，导致芯片未上电或未复位，bootrom 不运行，BLOCK_CNT 恒为 0。
- **LicheeRV**：U-Boot `cvi_board_init.c` 中 `mmio_write_32(0x0300104C, 0x3)`，在系统早期完成。
- **StarryOS 原问题**：pinmux 曾在 `sd1_host_init()` 里设置，而 `sd1_host_init()` 在 `aicbsp_sdio_init()` 中才被调用，即**晚于** `aicbsp_power_on()`。因此执行 `power_on()` 时 GPIOA_26 可能尚未配置为 GPIO，上电无效。
- **修复**：在 `aicbsp_power_on()` **最开头**调用 `set_wifi_power_pinmux_to_gpio()`（写 0x0300104C=0x3），再创建 `WifiGpioControl` 并执行 `power_on_and_reset()`。
- **代码**：
  - `backend.rs`：`pub fn set_wifi_power_pinmux_to_gpio()`
  - `flow.rs`：`aicbsp_power_on()` 内首行调用该函数。

### 2.2 极性（高=上电/释放复位，低=下电/复位）

- **当前**：`set_pin(pin, false)` = 低电平，`set_pin(pin, true)` = 高电平；上电序列为「低 50ms → 高 50ms」。
- **原理图**：仓库内**未找到** LicheeRV Nano / SG2002 的 PDF/原理图文件（已搜索 `.pdf`、`.sch`、板级相关路径）。极性以 **LicheeRV U-Boot 源码**为准。
- **U-Boot 依据**：`LicheeRV-Nano-Build/build/boards/sg200x/sg2002_licheervnano_sd/u-boot/cvi_board_init.c` 中 WiFi 上电序列为：
  - `0x0300104C = 0x3`（GPIOA_26 pinmux）
  - GPIOA DIR 置 bit26 为输出
  - **先写低** `0x03020000 &= ~(1<<26)` → 延时约 50ms → **再写高** `0x03020000 |= (1<<26)`
  - 即：**低 = 下电/复位，高 = 上电/释放复位**，与当前 `gpio.rs` 逻辑一致，**无需取反**。
- 若需核对板级走线：可查阅 Sipeed/LicheeRV 官方资料、或「05_SG2002_QFN_38 Board GPIO List」等板级文档（通常不在本仓库）。

### 2.3 时序（50ms 低 / 50ms 高）

- **LicheeRV**：Allwinner/Rockchip2 power(0)→**50ms**→power(1)→**50ms**；Amlogic **200ms**/200ms。
- **当前**：`gpio.rs` 中 `power_on()`：拉低 → `delay_spin_ms(50)` → 拉高 → `delay_spin_ms(50)`，与 Allwinner/Rockchip2 一致。

---

## 3. 复位

### 3.1 与电源共引脚（单引脚设计）

- **LicheeRV Nano W**：GPIOA_26 同时控制电源与复位，一次 power 序列即完成上电+复位。
- **当前**：`power_on_and_reset()` 直接调用 `power_on()`，无单独 reset 引脚，一致。

### 3.2 芯片侧“出复位”的保证

- 由上电序列（低→高）与稳定延时（50+500ms）共同保证；若仍不足，可增大 `POST_POWER_STABLE_MS`（如 1000ms）再试。

---

## 4. 时钟

### 4.1 SDIO 主机侧（SG2002）

- **RSTGEN (0x03003000)**：bit17 = SD1 复位，**0=复位、1=释放**。`sd1_host_init()` 中 `v | RSTGEN_SD1_BIT` 释放 SD1 复位。
- **CLKGEN (0x03002000)**：clk_en_0 的 bit21/22/23 使能 SD1 相关时钟。`sd1_host_init()` 中已使能。
- **SDMMC 控制器 CLK_CTL**：`enable_sd_interface_clock()` 中打开 INT_CLK、等 INT_CLK_STABLE、再开 SD_CLK，与 TRM 一致。
- **顺序**：RSTGEN 释放 → CLKGEN 使能 → 创建 Host → `enable_sd_interface_clock()`（内含 `reset_all()`）→ 卡枚举。与常见 SoC 顺序一致。

### 4.2 卡端（WiFi 芯片）时钟

- 卡时钟由主机在 CMD 阶段通过 SD_CLK 线提供；枚举时已用较低频率（FREQ_SEL_INIT），CMD5 成功说明卡已收到时钟并响应。
- 若 CMD5 已成功（日志中 OCR=0xa1300000），说明**至少枚举阶段**卡端有时钟；bootrom 是否在首包 IPC 前已稳定运行，依赖**上电/复位时序**（§2、§3）。

### 4.3 SDIO 数据阶段时钟（与 LicheeRV set_ios 对齐）

- **LicheeRV**：MMC 核心在 SDIO 枚举后通过 `host->ops->set_ios(host, &host->ios)` 设置 **clock** 与 bus_width；aic8800 可选 `feature.sdio_clock`，数据阶段通常高于 400kHz。
- **StarryOS**：枚举阶段使用 FREQ_SEL_INIT(0x80) ≈400kHz；**4-bit 切换后**在 `aicbsp_sdio_init()` 中调用 `host.set_ios_raw(true, Some(FREQ_SEL_DATA_RATE))` 将时钟提高到数据速率（FREQ_SEL=0），避免首包 CMD53 在 400kHz 下超时（inhibit_cmd=1、INT_STS=0）。与 LicheeRV「枚举低时钟、数据高时钟」一致。

---

## 5. 时序（上电到首包 IPC）

### 5.1 上电完成到 SDIO 主机 init 的间隔

- **当前**：`power_on_and_reset()` 返回后 → `verify_after_power_on()` → `delay_spin_ms(50)` → `axtask::sleep(POST_POWER_STABLE_MS)`，`POST_POWER_STABLE_MS=500`，即**50+500=550ms** 后再进入 `aicbsp_sdio_init()`（其中才调用 `sd1_host_init()`、枚举、F1 0x0B/0x11 等）。
- **LicheeRV**：Amlogic 平台 200ms 级延时；Allwinner 50ms 高后即 rescan，但 rescan 与 MMC 枚举本身也有延迟。
- **建议**：若仍无 CFM，可试将 `POST_POWER_STABLE_MS` 改为 300 或 500，排除“bootrom 需要更长就绪时间”的可能。

### 5.2 发首包 DBG_MEM_READ 前的延时

- **当前**：`send_dbg_mem_read_busrx()` 在 `send_msg()` 后 `axtask::sleep(100ms)`，再进入 `wait_done_until()`。即发完 IPC 后给 100ms 再开始轮询 BLOCK_CNT。
- **LicheeRV**：无显式 100ms；busrx 已起，靠 wait_for_completion 与中断/轮询收包。我们多出的 100ms 不会缩短设备响应时间，只影响主机何时开始轮询，对“芯片是否回 CFM”无负面影响。

### 5.3 F1 0x0B / 0x11 写到首包 IPC 的间隔

- **当前**：在 `aicbsp_sdio_init()` 末尾写 F1 0x0B=1、0x11=1，然后 `ensure_busrx_thread_started()`，再 return；首包在 `aicbsp_driver_fw_init()` 里发送，中间无额外延时。
- **若原厂要求**：写 0x0B/0x11 后需短延时再发 IPC，可在 `flow.rs` 中在 `ensure_busrx_thread_started()` 之后加 `axtask::sleep(Duration::from_millis(10))` 等再进入 driver_fw_init（当前未加，因 LicheeRV 未显式这样做）。

---

## 6. 检查清单小结（逐项自检）

| # | 项目 | 检查方法 | 当前状态 |
|---|------|----------|----------|
| 1 | GPIOA_26 pinmux 在驱动 GPIO **之前** 设为 GPIO(0x3) | 确认 `aicbsp_power_on()` 首行调 `set_wifi_power_pinmux_to_gpio()` | ✅ 已修复 |
| 2 | 上电序列：低 50ms → 高 50ms | 看 gpio.rs `power_on()` | ✅ 一致 |
| 3 | 极性：高=上电/释放复位 | 对照原理图，必要时对 set_pin 取反 | ⚠️ 需按板子确认 |
| 4 | 上电后到 sdio_init 前：50ms spin + 500ms sleep | flow.rs `POST_POWER_STABLE_MS=500` | ✅ 已加大便于 bootrom 就绪 |
| 5 | SD1 主机：先释 RSTGEN，再使能 CLKGEN，再 pinmux，再 CLK_CTL | backend.rs `sd1_host_init()` + `enable_sd_interface_clock()` | ✅ 已实现 |
| 6 | SDIO 数据/CMD/CLK pinmux 在枚举前设好 | sd1_host_init() 内 D0–CLK=0 | ✅ 已实现 |
| 7 | F1 block size=512、0x0B=1、0x11=1 在首包 IPC 前完成（1-bit 下完成 8801） | flow.rs aicbsp_sdio_init 内 3.2 | ✅ 已实现 |
| 7b | 4-bit 后提高 SDIO 时钟到数据速率（set_ios），避免 CMD53 超时 | flow.rs 3.6 + backend FREQ_SEL_DATA_RATE | ✅ 已实现 |
| 8 | busrx 在首包前已启动 | ensure_busrx_thread_started() 在 driver_fw_init 内首行 | ✅ 已实现 |
| 9 | 若仍无 CFM：试加大 POST_POWER_STABLE_MS（300/500ms） | 修改常量后重测 | 可选 |
| 10 | 若仍无 CFM：用示波器/逻辑分析仪确认 SDIO 写 0x107 及卡端是否有回读 | 硬件排查 | 可选 |

---

## 7. SDIO 初始化完整顺序（与 LicheeRV 逐项对照）

| 顺序 | 步骤 | LicheeRV | StarryOS (flow.rs / backend.rs) |
|------|------|----------|----------------------------------|
| 1 | 电源 pinmux + GPIO 上电 | U-Boot pinmux；平台 power(0)→50ms→power(1) | set_wifi_power_pinmux_to_gpio → power_on_and_reset (50/50ms) |
| 2 | 上电后稳定延时 | 平台 50ms～200ms 或 Linux 启动时间 | 50ms spin + stable_ms sleep (默认 500ms) |
| 3 | SDIO pinmux (D0–D3/CMD/CLK) | U-Boot 拉高后即设 | set_sd1_sdio_pinmux_after_power（在稳定延时前） |
| 4 | 主机 RSTGEN/CLKGEN + CLK_CTL 400kHz | MMC host 驱动 | sd1_host_init → enable_sd_interface_clock (FREQ_SEL_INIT) |
| 5 | 卡枚举 CMD0→CMD5→CMD3→CMD7 | MMC 核心 | sdio_card_init，保持 1-bit |
| 6 | F1 使能 + IO_READY + CIS/chipmatch | sdio_read_cccr、sdio_read_common_cis | read_byte(0x02)\|0x02、轮询 0x03、probe_from_sdio_cis |
| 7 | F1 set_block_size(512)、0x0B/0x11/0x04 | aicwf_sdio_func_init、bus_start | 3.2 在 **1-bit** 下完成（避免 4-bit 后首 CMD52 超时） |
| 8 | 4-bit 总线 | sdio_enable_4bit_bus → mmc_set_bus_width(4) | enable_4bit_bus (CCCR_IF + HOST_CTRL1) + 10ms 延时 |
| 9 | **数据阶段时钟** | host->ops->set_ios(clock) / feature.sdio_clock | set_ios_raw(true, Some(FREQ_SEL_DATA_RATE)) + 1ms 延时 |
| 10 | F2（非 8801）、set_block_size(2,512) | 部分芯片 | 4. 仅非 8801 |
| 11 | bustx/busrx 线程 | bus_init 内 kthread_run | ensure_bustx_thread_started / ensure_busrx_thread_started |

## 8. 本次代码修改摘要

- **backend.rs**：新增 `pub fn set_wifi_power_pinmux_to_gpio()`，仅写 0x0300104C=0x3，供上电前调用。
- **flow.rs**：在 `aicbsp_power_on()` 中**第一行**调用 `super::backend::set_wifi_power_pinmux_to_gpio()`，再执行 `WifiGpioControl::new()` / `init()` / `power_on_and_reset()`，确保在驱动 GPIOA_26 之前该引脚已处于 GPIO 模式。
- **clock 与 4-bit 后 CMD53 超时**：枚举阶段保持 400kHz；4-bit 切换后首条 CMD53（bustx 写 WR_FIFO）易出现 wait_cmd_complete 超时（INT_STS=0、inhibit_cmd=1）。与 LicheeRV 一致在**数据阶段提高时钟**：backend 增加 `FREQ_SEL_DATA_RATE`，flow 在 3.6 步调用 `host.set_ios_raw(true, Some(FREQ_SEL_DATA_RATE))` 并 1ms 延时。

按上述清单逐项确认后，若 BLOCK_CNT 仍为 0，可再结合《BLOCK_CNT恒为0_根因分析.md》从“芯片未响应”的其它可能（协议、硬件电气）继续缩范围。
